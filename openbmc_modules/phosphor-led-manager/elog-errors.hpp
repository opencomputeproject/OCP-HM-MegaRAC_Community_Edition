// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <phosphor-logging/elog.hpp>
#include <phosphor-logging/log.hpp>
#include <sdbusplus/exception.hpp>

#include <string>
#include <tuple>
#include <type_traits>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace Error
{
struct InventoryPathError;
} // namespace Error
} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace Error
{
struct ObjectNotFoundError;
} // namespace Error
} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace Error
{
struct MethodError;
} // namespace Error
} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Fru
{
namespace Monitor
{
namespace _InventoryPathError
{

struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)){};
    type _entry;
};

} // namespace _InventoryPathError

struct InventoryPathError : public sdbusplus::exception_t
{
    static constexpr auto errName =
        "xyz.openbmc_project.Led.Fru.Monitor.InventoryPathError";
    static constexpr auto errDesc = "Invalid Inventory Path.";
    static constexpr auto L = level::INFO;
    using PATH = _InventoryPathError::PATH;
    using metadata_types = std::tuple<PATH>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Monitor
} // namespace Fru
} // namespace Led
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Led::Fru::Monitor::
                              Error::InventoryPathError>
{
    using type = xyz::openbmc_project::Led::Fru::Monitor::InventoryPathError;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace _MethodError
{

struct METHOD_NAME
{
    static constexpr auto str = "METHOD_NAME=%s";
    static constexpr auto str_short = "METHOD_NAME";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr METHOD_NAME(const char* a) : _entry(entry(str, a)){};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)){};
    type _entry;
};
struct INTERFACE
{
    static constexpr auto str = "INTERFACE=%s";
    static constexpr auto str_short = "INTERFACE";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr INTERFACE(const char* a) : _entry(entry(str, a)){};
    type _entry;
};

} // namespace _MethodError

struct MethodError : public sdbusplus::exception_t
{
    static constexpr auto errName =
        "xyz.openbmc_project.Led.Mapper.MethodError";
    static constexpr auto errDesc = "Failed to invoke ObjectMapper method";
    static constexpr auto L = level::INFO;
    using METHOD_NAME = _MethodError::METHOD_NAME;
    using PATH = _MethodError::PATH;
    using INTERFACE = _MethodError::INTERFACE;
    using metadata_types = std::tuple<METHOD_NAME, PATH, INTERFACE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Led::Mapper::Error::MethodError>
{
    using type = xyz::openbmc_project::Led::Mapper::MethodError;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Led
{
namespace Mapper
{
namespace _ObjectNotFoundError
{

struct METHOD_NAME
{
    static constexpr auto str = "METHOD_NAME=%s";
    static constexpr auto str_short = "METHOD_NAME";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr METHOD_NAME(const char* a) : _entry(entry(str, a)){};
    type _entry;
};
struct PATH
{
    static constexpr auto str = "PATH=%s";
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry(str, a)){};
    type _entry;
};
struct INTERFACE
{
    static constexpr auto str = "INTERFACE=%s";
    static constexpr auto str_short = "INTERFACE";
    using type = std::tuple<std::decay_t<decltype(str)>, const char*>;
    explicit constexpr INTERFACE(const char* a) : _entry(entry(str, a)){};
    type _entry;
};

} // namespace _ObjectNotFoundError

struct ObjectNotFoundError : public sdbusplus::exception_t
{
    static constexpr auto errName =
        "xyz.openbmc_project.Led.Mapper.ObjectNotFoundError";
    static constexpr auto errDesc = "Failed to get response from the method.";
    static constexpr auto L = level::INFO;
    using METHOD_NAME = _ObjectNotFoundError::METHOD_NAME;
    using PATH = _ObjectNotFoundError::PATH;
    using INTERFACE = _ObjectNotFoundError::INTERFACE;
    using metadata_types = std::tuple<METHOD_NAME, PATH, INTERFACE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Mapper
} // namespace Led
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Led::Mapper::Error::ObjectNotFoundError>
{
    using type = xyz::openbmc_project::Led::Mapper::ObjectNotFoundError;
};

} // namespace details

} // namespace logging

} // namespace phosphor
