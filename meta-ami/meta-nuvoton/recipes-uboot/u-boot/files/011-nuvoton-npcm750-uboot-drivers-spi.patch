diff -Naur a/drivers/spi/Kconfig b/drivers/spi/Kconfig
--- a/drivers/spi/Kconfig	2019-07-22 22:57:53.000000000 -0400
+++ b/drivers/spi/Kconfig	2020-05-25 15:11:22.099900556 -0400
@@ -301,6 +301,16 @@
 	  This option is used to enable ZynqMP QSPI controller driver which
 	  is used to communicate with qspi flash devices.
 
+config NPCM750_FIU_SPI
+	bool "FIU driver for NPCM750"
+	help
+	  Flash Interface Unit controller for NPCM750.
+
+config NPCM750_PSPI
+	bool "PSPI driver for NPCM750 SPI"
+	help
+	  PSPI driver for NPCM750
+
 endif # if DM_SPI
 
 config SOFT_SPI
diff -Naur a/drivers/spi/Makefile b/drivers/spi/Makefile
--- a/drivers/spi/Makefile	2019-07-22 22:57:53.000000000 -0400
+++ b/drivers/spi/Makefile	2020-05-25 15:11:22.295902613 -0400
@@ -62,3 +62,5 @@
 obj-$(CONFIG_ZYNQ_SPI) += zynq_spi.o
 obj-$(CONFIG_ZYNQ_QSPI) += zynq_qspi.o
 obj-$(CONFIG_ZYNQMP_GQSPI) += zynqmp_gqspi.o
+obj-$(CONFIG_NPCM750_FIU_SPI) += npcm750_fiu_spi.o
+obj-$(CONFIG_NPCM750_PSPI) += npcm750_pspi.o
diff -Naur a/drivers/spi/npcm750_fiu_spi.c b/drivers/spi/npcm750_fiu_spi.c
--- a/drivers/spi/npcm750_fiu_spi.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/spi/npcm750_fiu_spi.c	2020-05-25 15:11:22.103900598 -0400
@@ -0,0 +1,562 @@
+/*
+ *  Copyright (c) 2017 Nuvoton Technology Corp.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spi.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/gcr.h>
+#include <asm/arch/fiu.h>
+#include <asm/arch/spi_flash.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+enum npcm750_sf_state {
+	SF_CMD		    = 0,
+	SF_ID		    = 1,
+	SF_ADDR		    = 2,
+	SF_READ		    = 3,
+	SF_WRITE	    = 4,
+	SF_ERASE	    = 5,
+	SF_READ_STATUS	    = 6,
+	SF_READ_STATUS1	    = 7,
+	SF_WRITE_STATUS	    = 8,
+	SF_READ_BAR,
+	SF_WRITE_BAR,
+};
+
+/* Bits for the status register */
+#define STAT_WIP        (1 << 0)
+#define STAT_WEL        (1 << 1)
+
+static const char *npcm750_sf_state_name(enum npcm750_sf_state state)
+{
+	static const char * const states[] = {
+		"CMD", "ID", "ADDR", "READ", "WRITE", "ERASE", "READ_STATUS",
+		"READ_STATUS1", "WRITE_STATUS", "READ_BAR", "WRITE_BAR"
+	};
+	return states[state];
+}
+
+struct npcm750_fiu_spi_platdata {
+	void* regs;
+	s32 frequency;
+	u32 dev_num;
+};
+
+struct npcm750_fiu_spi_priv {
+	struct npcm750_fiu_regs *regs;
+	u32 cs;
+	enum fiu_moudle_tag dev_num;
+	enum npcm750_sf_state state;
+	u16 status; /* The current flash status (see STAT_XXX defines above) */
+	u32 cmd;
+};
+
+static void gcr_muxfiu(enum fiu_moudle_tag dev_num,
+		bool cs0_en, bool cs1_en, bool cs2_en,
+		bool cs3_en, bool quad_mode)
+{
+	struct npcm750_gcr *gcr = (struct npcm750_gcr *)npcm750_get_base_gcr();
+
+	switch (dev_num) {
+	case FIU_MODULE_0:
+		/* config CS */
+		if (cs0_en)
+			/* nothing to do */;
+		/* config CS1 */
+		if (cs1_en)
+			writel(readl(&gcr->mfsel1) | (1 << MFSEL1_S0CS1SEL),
+				&gcr->mfsel1);
+		/* config CS2 */
+		if (cs2_en)
+			writel(readl(&gcr->mfsel1) | (1 << MFSEL1_S0CS2SEL),
+				&gcr->mfsel1);
+		/* config CS3 */
+		if (cs3_en)
+			writel(readl(&gcr->mfsel1) | (1 << MFSEL1_S0CS3SEL),
+				&gcr->mfsel1);
+		/* select io bus width (1/2/4  <=> single/dual/quad ) */
+		if (quad_mode) {
+			/*  0: GPIO33/SPI0D2 ,1: nSPI0CS2 */
+			writel(readl(&gcr->mfsel1) & ~(1 << MFSEL1_S0CS2SEL),
+				&gcr->mfsel1);
+			writel(readl(&gcr->mfsel1) & ~(1 << MFSEL1_S0CS3SEL),
+				&gcr->mfsel1);
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_SP0QSEL),
+				&gcr->mfsel4);
+		}
+		break;
+	case FIU_MODULE_3:
+		/* Select SPI3 */
+		writel(readl(&gcr->mfsel4) | (1 << MFSEL4_SP3SEL),
+			&gcr->mfsel4);
+		/* config CS */
+		if (cs0_en)
+			/* nothing to do */;
+		/* config CS1 */
+		if (cs1_en)
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_S3CS1SEL),
+				&gcr->mfsel4);
+		/* Config CS2 */
+		if (cs2_en)
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_S3CS2SEL),
+				&gcr->mfsel4);
+		/* Config CS3 */
+		if (cs3_en)
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_S3CS3SEL),
+				&gcr->mfsel4);
+		/* select io bus width (1/2/4  <=> single/dual/quad ) */
+		if (quad_mode) {
+			writel(readl(&gcr->mfsel4) & ~(1 << MFSEL4_S3CS2SEL),
+				&gcr->mfsel4);
+			writel(readl(&gcr->mfsel4) & ~(1 << MFSEL4_S3CS3SEL),
+				&gcr->mfsel4);
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_SP3QSEL),
+				&gcr->mfsel4);
+		}
+		break;
+	case FIU_MODULE_X:
+		/* config CS */
+		if (cs0_en)
+			/* nothing to do */;
+		/* config CS1 */
+		if (cs1_en)
+			writel(readl(&gcr->mfsel4) | (1 << MFSEL4_SXCS1SEL),
+				&gcr->mfsel4);
+		writel(readl(&gcr->mfsel4) | (1 << MFSEL4_SPXSEL),
+			&gcr->mfsel4);
+		break;
+	default:
+		break;
+	};
+}
+
+static void fiu_spi_cs_activate(struct udevice *dev)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+
+	priv->state = SF_CMD;
+	priv->cmd = SF_CMD;
+}
+
+static void fiu_spi_cs_deactivate(struct udevice *dev)
+{
+	return;
+}
+
+static int npcm750_fiu_spi_set_speed(struct udevice *bus, uint speed)
+{
+	return 0;
+}
+
+static int npcm750_fiu_spi_set_mode(struct udevice *bus, uint mode)
+{
+	return 0;
+}
+
+static int npcm750_fiu_spi_claim_bus(struct udevice *dev)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+	struct dm_spi_slave_platdata *slave_plat =
+			dev_get_parent_platdata(dev);
+	bool cs0_en, cs1_en, cs2_en, cs3_en, quad_mode;
+
+	cs0_en = cs1_en = cs2_en = cs3_en = quad_mode = false;
+
+	switch (slave_plat->cs) {
+	case 0:
+	default:
+		cs0_en = true;
+		quad_mode = true;
+		break;
+	case 1:
+		cs1_en = true;
+		quad_mode = true;
+	case 2:
+	case 3:
+	case 4:
+		break;
+	};
+
+	/* SPI flash init */
+	gcr_muxfiu(priv->dev_num, cs0_en, cs1_en, cs2_en, cs3_en, quad_mode);
+	return 0;
+}
+
+static int npcm750_fiu_spi_release_bus(struct udevice *dev)
+{
+	return 0;
+}
+
+static int fiu_uma_read(struct udevice *bus, u32 address, uint8_t *tx,
+			bool is_address_size, u32 data_size)
+{
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+	struct npcm750_fiu_regs *regs = priv->regs;
+	u32 data_reg[4];
+	u32 uma_cfg = 0;
+	u32 address_size = 0;
+
+	uma_cfg = uma_cfg | (1 << FIU_UMA_CFG_CMDSIZ);
+
+	if (is_address_size)
+		address_size = 3;
+
+	uma_cfg = (uma_cfg & ~(0x07 << FIU_UMA_CFG_ADDSIZ))
+			| (address_size << FIU_UMA_CFG_ADDSIZ);
+
+	/* Set the UMA address registers */
+	writel(address, &regs->uma_addr);
+
+	/* Set data size and direction */
+	uma_cfg = (uma_cfg & ~(0x1f << FIU_UMA_CFG_RDATSIZ)) |
+		(data_size << FIU_UMA_CFG_RDATSIZ);
+	uma_cfg = uma_cfg & ~(0x1f << FIU_UMA_CFG_WDATSIZ);
+
+	/* Set UMA CFG */
+	writel(uma_cfg, &regs->uma_cfg);
+
+	/* Initiate the read */
+	writel(readl(&regs->uma_cts) | (1 << FIU_UMA_CTS_EXEC_DONE),
+		&regs->uma_cts);
+
+	/* wait for indication that transaction has terminated */
+	while ((readl(&regs->uma_cts) & (1 << FIU_UMA_CTS_EXEC_DONE))
+		== FIU_TRANS_STATUS_IN_PROG);
+
+	/* copy read data from FIU_UMA_DB0-3 regs to data buffer */
+	/* Set the UMA data registers - FIU_UMA_DB0-3 */
+	if (data_size >= FIU_UMA_DATA_SIZE_1)
+		data_reg[0] = readl(&regs->uma_dr0);
+	if (data_size >= FIU_UMA_DATA_SIZE_5)
+		data_reg[1] = readl(&regs->uma_dr1);
+	if (data_size >= FIU_UMA_DATA_SIZE_9)
+		data_reg[2] = readl(&regs->uma_dr2);
+	if (data_size >= FIU_UMA_DATA_SIZE_13)
+		data_reg[3] = readl(&regs->uma_dr3);
+
+	memcpy(tx, data_reg, data_size);
+
+	return 0;
+}
+
+static int fiu_uma_write(struct udevice *bus, u32 address, const uint8_t *rx,
+			bool is_address_size, u32 data_size)
+{
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+	struct npcm750_fiu_regs *regs = priv->regs;
+	u32 data_reg[4];
+	u32 uma_cfg = 0;
+	u32 address_size = 0;
+
+	uma_cfg = uma_cfg | (1 << FIU_UMA_CFG_CMDSIZ);
+
+	if (is_address_size)
+		address_size = 3;
+
+	uma_cfg = (uma_cfg & ~(0x07 << FIU_UMA_CFG_ADDSIZ))
+			| (address_size << FIU_UMA_CFG_ADDSIZ);
+	/* Set the UMA address registers */
+	writel(address, &regs->uma_addr);
+
+	/* Set the UMA data registers - FIU_UMA_DB0-3 */
+	memcpy(data_reg, rx, data_size);
+
+	if (data_size >= FIU_UMA_DATA_SIZE_1)
+		writel(data_reg[0], &regs->uma_dw0);
+	if (data_size >= FIU_UMA_DATA_SIZE_5)
+		writel(data_reg[1], &regs->uma_dw1);
+	if (data_size >= FIU_UMA_DATA_SIZE_9)
+		writel(data_reg[2], &regs->uma_dw2);
+	if (data_size >= FIU_UMA_DATA_SIZE_13)
+		writel(data_reg[3], &regs->uma_dw3);
+
+	/* Set data size and direction */
+	uma_cfg = (uma_cfg & ~(0x1f << FIU_UMA_CFG_WDATSIZ)) |
+		(data_size << FIU_UMA_CFG_WDATSIZ);
+	uma_cfg = uma_cfg & ~(0x1f << FIU_UMA_CFG_RDATSIZ);
+
+	/* Set UMA status */
+	writel(uma_cfg, &regs->uma_cfg);
+
+	/* Initiate the read */
+	writel(readl(&regs->uma_cts) | (1 << FIU_UMA_CTS_EXEC_DONE),
+		&regs->uma_cts);
+
+	/* wait for indication that transaction has terminated */
+	while ((readl(&regs->uma_cts) & (1 << FIU_UMA_CTS_EXEC_DONE))
+		== FIU_TRANS_STATUS_IN_PROG);
+
+	return 0;
+}
+
+static int npcm750_sf_process_cmd(struct udevice *dev, const u8 *rx, u8 *tx)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+	struct npcm750_fiu_regs *regs = priv->regs;
+	enum npcm750_sf_state oldstate = priv->state;
+	struct dm_spi_slave_platdata *slave_plat =
+			dev_get_parent_platdata(dev);
+
+	priv->cmd = rx[0];
+	/* set device number - DEV_NUM in FIU_UMA_CTS.
+	   Select the chip select to be used in the following
+	   UMA transaction */
+	writel((readl(&regs->uma_cts) & ~(0x03 << FIU_UMA_CTS_DEV_NUM))
+			| ((slave_plat->cs & 0x3) << FIU_UMA_CTS_DEV_NUM),
+			&regs->uma_cts);
+
+	/* set transaction code in FIU_UMA_CODE */
+	writel((readl(&regs->uma_cmd) & ~(0xff << FIU_UMA_CMD_CMD))
+			| (priv->cmd << FIU_UMA_CMD_CMD), &regs->uma_cmd);
+
+	switch (priv->cmd) {
+		case SPI_READ_JEDEC_ID_CMD:
+			priv->state = SF_ID;
+			priv->cmd = SF_ID;
+			break;
+		case SPI_READ_STATUS_REG_CMD:
+			priv->state = SF_READ_STATUS;
+			break;
+		case SPI_WRITE_STATUS_REG_CMD:
+			priv->state = SF_WRITE_STATUS;
+			break;
+		case SPI_EXTNADDR_RDEAR_CMD:
+			priv->state = SF_READ_BAR;
+			break;
+		case SPI_EXTNADDR_WREAR_CMD:
+			priv->state = SF_WRITE_BAR;
+			break;
+		case SPI_WRITE_ENABLE_CMD:
+			fiu_uma_write(bus, 0x0, NULL, false, 0);
+			priv->status |= STAT_WEL;
+			break;
+		case SPI_WRITE_DISABLE_CMD:
+			priv->status &= ~STAT_WEL;
+			break;
+		case SPI_4K_SECTOR_ERASE_CMD:
+		case SPI_64K_BLOCK_ERASE_CMD:
+			priv->state = SF_ADDR;
+			break;
+		case SPI_PAGE_PRGM_CMD:
+			writel(readl(&regs->uma_cts)
+				& ~(1 << FIU_UMA_CTS_SW_CS), &regs->uma_cts);
+			priv->state = SF_ADDR;
+			break;
+		default:
+			printf("%s: unknown cmd:0x%x\n", __func__, priv->cmd);
+			return -EIO;
+	}
+
+	if (oldstate != priv->state)
+		debug(" %s: transition to %s state\n", dev->name,
+				npcm750_sf_state_name(priv->state));
+
+	return 0;
+}
+
+static int npcm750_fiu_spi_xfer(struct udevice *dev, unsigned int bitlen,
+			const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+	struct npcm750_fiu_regs *regs = priv->regs;
+	struct dm_spi_slave_platdata *slave_plat =
+			dev_get_parent_platdata(dev);
+	const uint8_t *rx = dout;
+	uint8_t *tx = din;
+	int bytes = bitlen / 8;
+	u32 address, pos = 0;
+	u32 remain_data = 0; /* For SF_WRITE */
+	int ret;
+	//debug("%s: flags 0x%lx\n", __func__, flags);
+
+	if (flags & SPI_XFER_BEGIN)
+		fiu_spi_cs_activate(dev);
+
+	if ((flags & SPI_XFER_MMAP) || (flags & SPI_XFER_MMAP_END))
+		goto done;
+
+	if (priv->state == SF_CMD) {
+		ret = npcm750_sf_process_cmd(dev, rx, tx);
+		if (ret)
+			return ret;
+		++pos;
+	}
+
+	if (priv->state == SF_WRITE)
+		remain_data = bytes % CHUNK_SIZE;
+
+	while (pos < bytes) {
+		switch (priv->state) {
+		case SF_ID:
+			fiu_uma_read(bus, 0x0, tx, false, bytes);
+			pos += bytes;
+			break;
+		case SF_READ_STATUS:
+			fiu_uma_read(bus, 0x0, tx, false, 1);
+			pos ++;
+			break;
+		case SF_WRITE_STATUS:
+			fiu_uma_write(bus, 0x0, rx, false, 1);
+			pos ++;
+			break;
+		case SF_READ_BAR:
+			fiu_uma_read(bus, 0x0, tx, false, 1);
+			pos ++;
+			break;
+		case SF_WRITE_BAR:
+			fiu_uma_write(bus, 0x0, rx, false, 1);
+			pos ++;
+			break;
+		case SF_ADDR:
+			address = (rx[1] << 16) | (rx[2] << 8) | (rx[3] << 0);
+			pos += 3;
+			switch (priv->cmd) {
+			case SPI_4K_SECTOR_ERASE_CMD:
+			case SPI_64K_BLOCK_ERASE_CMD:
+				if (!(priv->status & STAT_WEL)) {
+					printf("%s: write enable not set"
+						" before erase!\n",
+						__func__);
+				}
+				fiu_uma_write(bus, address, NULL, true, 0);
+				priv->status &= ~STAT_WEL;
+				break;
+			case SPI_PAGE_PRGM_CMD:
+				priv->state = SF_WRITE;
+				fiu_uma_write(bus, address, NULL, true, 0);
+				break;
+			}
+			break;
+		case SF_WRITE:
+			if (!(priv->status & STAT_WEL)) {
+				printf("%s: write enable not set"
+					" before write!\n",
+					__func__);
+				goto done;
+			}
+
+			writel((readl(&regs->uma_cts) &
+				~(0x03 << FIU_UMA_CTS_DEV_NUM))
+				| ((slave_plat->cs & 0x3) << FIU_UMA_CTS_DEV_NUM),
+				&regs->uma_cts);
+
+			/* set transaction code in FIU_UMA_CODE */
+			writel((readl(&regs->uma_cmd) &
+				~(0xff << FIU_UMA_CMD_CMD))
+				| (rx[0] << FIU_UMA_CMD_CMD),
+				&regs->uma_cmd);
+
+			if ((pos + remain_data) < bytes) {
+				fiu_uma_write(bus, 0x0, &rx[1], false,
+						CHUNK_SIZE - 1);
+				pos = pos + CHUNK_SIZE;
+				rx = rx + CHUNK_SIZE;
+			} else if (remain_data) {
+				fiu_uma_write(bus, 0x0, &rx[1], false,
+						remain_data - 1);
+				pos = pos + remain_data;
+			}
+
+			if (pos >= bytes) {
+				writel(readl(&regs->uma_cts) |
+					(1 << FIU_UMA_CTS_SW_CS),
+					&regs->uma_cts);
+				priv->status &= ~STAT_WEL;
+			}
+			break;
+		default:
+			printf("%s: no idea what to do.\n", __func__);
+			goto done;
+		}
+	}
+
+done:
+	if (flags & SPI_XFER_END)
+		fiu_spi_cs_deactivate(dev);
+
+	return pos == bytes ? 0 : -EIO;
+}
+
+static int npcm750_fiu_spi_ofdata_to_platdata(struct udevice *bus)
+{
+	struct npcm750_fiu_spi_platdata *plat = dev_get_platdata(bus);
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(bus);
+
+	plat->regs = dev_read_addr_ptr(bus);
+
+	/* Use 500KHz as a suitable default */
+	plat->frequency = fdtdec_get_int(blob, node, "spi-max-frequency",
+			500000);
+
+	plat->dev_num = fdtdec_get_int(blob, node, "index", 0);
+
+	return 0;
+}
+
+static int npcm750_fiu_spi_probe(struct udevice *bus)
+{
+	struct npcm750_fiu_spi_platdata *plat = dev_get_platdata(bus);
+	struct npcm750_fiu_spi_priv *priv = dev_get_priv(bus);
+
+	debug("%s\n", __func__);
+	priv->regs = (struct npcm750_fiu_regs *)plat->regs;
+	priv->dev_num = (enum fiu_moudle_tag)plat->dev_num;
+
+	return 0;
+}
+
+static const struct dm_spi_ops npcm750_fiu_spi_ops = {
+	.claim_bus      = npcm750_fiu_spi_claim_bus,
+	.release_bus    = npcm750_fiu_spi_release_bus,
+	.xfer           = npcm750_fiu_spi_xfer,
+	.set_speed      = npcm750_fiu_spi_set_speed,
+	.set_mode       = npcm750_fiu_spi_set_mode,
+	/*
+	 * cs_info is not needed, since we require all chip selects to be
+	 * in the device tree explicitly
+	 */
+};
+
+static const struct udevice_id npcm750_fiu_spi_ids[] = {
+	{ .compatible = "nuvoton,npcm750-fiu" },
+	{ }
+};
+
+U_BOOT_DRIVER(npcm750_fiu_spi) = {
+	.name   = "npcm750_fiu_spi",
+	.id     = UCLASS_SPI,
+	.of_match = npcm750_fiu_spi_ids,
+	.ops    = &npcm750_fiu_spi_ops,
+	.ofdata_to_platdata = npcm750_fiu_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct npcm750_fiu_spi_platdata),
+	.priv_auto_alloc_size = sizeof(struct npcm750_fiu_spi_priv),
+	.probe  = npcm750_fiu_spi_probe,
+};
diff -Naur a/drivers/spi/npcm750_pspi.c b/drivers/spi/npcm750_pspi.c
--- a/drivers/spi/npcm750_pspi.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/spi/npcm750_pspi.c	2020-05-25 15:11:22.303902696 -0400
@@ -0,0 +1,297 @@
+/*
+ *  Copyright (c) 2017 Nuvoton Technology Corp.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <spi.h>
+#include <clk.h>
+#include <fdtdec.h>
+#include <asm/io.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/gcr.h>
+#include <asm/arch/pspi.h>
+#include <asm/arch/spi_flash.h>
+#include <asm/gpio.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+struct npcm750_pspi_platdata {
+	phys_addr_t regs;
+	s32 frequency;
+	u32 dev_num;
+	struct gpio_desc cs_gpio;
+};
+
+struct npcm750_pspi_priv {
+	struct npcm750_pspi_regs *pspi_regs;
+	struct clk pspi_clk;
+	u32 cs;
+	enum pspi_dev pspi_dev_num;
+};
+
+static void gcr_mux_pspi(enum pspi_dev dev_num)
+{
+	struct npcm750_gcr *gcr = (struct npcm750_gcr *)npcm750_get_base_gcr();
+
+	switch (dev_num) {
+	case PSPI1_DEV:
+	default:
+		writel((readl(&gcr->mfsel3) & ~(0x3 << MFSEL3_PSPI1SEL))
+				| (0x2 << MFSEL3_PSPI1SEL), &gcr->mfsel3);
+		break;
+	case PSPI2_DEV:
+		writel(readl(&gcr->mfsel3) | (0x1 << MFSEL3_PSPI2SEL),
+				&gcr->mfsel3);
+		break;
+	}
+}
+
+static void spi_cs_activate(struct udevice *dev)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_pspi_platdata *plat = dev_get_platdata(bus);
+
+	dm_gpio_set_value(&plat->cs_gpio, 0);
+
+	return;
+}
+
+static void spi_cs_deactivate(struct udevice *dev)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_pspi_platdata *plat = dev_get_platdata(bus);
+
+	dm_gpio_set_value(&plat->cs_gpio, 1);
+
+	return;
+}
+
+
+static int npcm750_pspi_claim_bus(struct udevice *dev)
+{
+	return 0;
+}
+
+static int npcm750_pspi_release_bus(struct udevice *dev)
+{
+	return 0;
+}
+
+static int npcm750_pspi_xfer(struct udevice *dev, unsigned int bitlen,
+			const void *dout, void *din, unsigned long flags)
+{
+	struct udevice *bus = dev->parent;
+	struct npcm750_pspi_priv *priv = dev_get_priv(bus);
+	struct npcm750_pspi_regs *regs = priv->pspi_regs;
+	unsigned int bytes = bitlen / 8;
+	const unsigned char *rx = dout;
+	unsigned char *tx = din;
+	int i;
+
+	/* Cleaning junk data in the buffer */
+	while (readb(&regs->pspi_stat) & (0x1 << PSPI_STAT_RBF))
+		readb(&regs->pspi_data);
+
+	if (flags & SPI_XFER_BEGIN)
+		/* Setting chip select low to start transaction */
+		spi_cs_activate(dev);
+
+	/* Writing and reading the data */
+	for (i = 0; i < bytes; i++) {
+
+		/* Making sure we can write */
+		while (readb(&regs->pspi_stat) & (0x1 << PSPI_STAT_BSY));
+
+		if (rx)
+			writeb(*rx++, &regs->pspi_data);
+		else
+			writeb(0, &regs->pspi_data);
+
+		/* Wait till write completed */
+		while (readb(&regs->pspi_stat) & (0x1 << PSPI_STAT_BSY));
+
+		/* Waiting till reading is finished*/
+		while (!(readb(&regs->pspi_stat) & (0x1 << PSPI_STAT_RBF)));
+
+		if (tx)
+			*tx++ = readb(&regs->pspi_data);
+	}
+
+	if (flags & SPI_XFER_END) {
+		while (readb(&regs->pspi_stat) & (0x1 << PSPI_STAT_BSY));
+
+		spi_cs_deactivate(dev);
+	}
+
+	return 0;
+}
+
+static int npcm750_pspi_set_speed(struct udevice *bus, uint speed)
+{
+	struct npcm750_pspi_priv *priv = dev_get_priv(bus);
+	int divisor;
+	ulong apb_clock;
+
+	apb_clock = clk_get_rate(&priv->pspi_clk);
+	if (!apb_clock)
+		return -EINVAL;
+
+	/* Disabling the module for configuration */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) & ~(0x1 << PSPI_CTL1_SPIEN),
+		&priv->pspi_regs->pspi_ctl1);
+
+	/* Calculating divisor */
+	divisor = (apb_clock / (2 * speed)) - 1;
+
+	/* If requested clock frequency is to big we return ERROR */
+	if (divisor <= 0)
+		return -EINVAL;
+
+	/* Setting the divisor */
+	writew((readw(&priv->pspi_regs->pspi_ctl1) &
+				~(0x7f << PSPI_CTL1_SCDV6_0)) |
+			(divisor << PSPI_CTL1_SCDV6_0),
+			&priv->pspi_regs->pspi_ctl1);
+
+	/* We emit zeros in idle (default behaivor) */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) &
+			~(0x1 << PSPI_CTL1_SCIDL),
+			&priv->pspi_regs->pspi_ctl1);
+
+	/* Enabling the PSPI module */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) | (0x1 << PSPI_CTL1_SPIEN),
+			&priv->pspi_regs->pspi_ctl1);
+
+	return 0;
+}
+
+static int npcm750_pspi_set_mode(struct udevice *bus, uint mode)
+{
+	struct npcm750_pspi_priv *priv = dev_get_priv(bus);
+	enum pspi_transfer_mode pspi_mode;
+
+	/* Disabling the module for configuration */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) & ~(0x1 << PSPI_CTL1_SPIEN),
+			&priv->pspi_regs->pspi_ctl1);
+
+
+	if (((mode & SPI_CPHA) && !(mode & SPI_CPOL)) ||
+			(!(mode & SPI_CPHA) && (mode & SPI_CPOL)))
+		pspi_mode = PSPI_WRITE_FALLING_EDGE;
+	else
+		pspi_mode = PSPI_WRITE_RISING_EDGE;
+
+	switch (pspi_mode) {
+	case PSPI_WRITE_RISING_EDGE:
+		writew(readw(&priv->pspi_regs->pspi_ctl1) |
+				(0x1 << PSPI_CTL1_SCM),
+				&priv->pspi_regs->pspi_ctl1);
+		break;
+	case PSPI_WRITE_FALLING_EDGE:
+		writew(readw(&priv->pspi_regs->pspi_ctl1) &
+				~(0x1 << PSPI_CTL1_SCM),
+				&priv->pspi_regs->pspi_ctl1);
+		break;
+	default:
+		break;
+	}
+
+	/* We emit zeros in idle (default behaivor) */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) &
+			~(0x1 << PSPI_CTL1_SCIDL),
+			&priv->pspi_regs->pspi_ctl1);
+
+	/* Enabling the PSPI module */
+	writew(readw(&priv->pspi_regs->pspi_ctl1) | (0x1 << PSPI_CTL1_SPIEN),
+			&priv->pspi_regs->pspi_ctl1);
+
+	return 0;
+}
+
+static int npcm750_spi_ofdata_to_platdata(struct udevice *bus)
+{
+	struct npcm750_pspi_platdata *plat = dev_get_platdata(bus);
+	const void *blob = gd->fdt_blob;
+	int node = dev_of_offset(bus);
+
+	plat->regs = (phys_addr_t)dev_read_addr_ptr(bus);
+	/* Use 500KHz as a suitable default */
+	plat->frequency = fdtdec_get_int(blob, node, "spi-max-frequency",
+			500000);
+
+	plat->dev_num = fdtdec_get_int(blob, node, "index", 0);
+
+	return 0;
+}
+
+static int npcm750_pspi_probe(struct udevice *bus)
+{
+	struct npcm750_pspi_platdata *plat = dev_get_platdata(bus);
+	struct npcm750_pspi_priv *priv = dev_get_priv(bus);
+	int node = dev_of_offset(bus);
+	int ret;
+
+	ret = clk_get_by_index(bus, 0, &priv->pspi_clk);
+	if (ret < 0) {
+		printf("%s:Probe failed: Failed to get clk!\n", __func__);
+		return ret;
+	}
+
+	gcr_mux_pspi(priv->pspi_dev_num);
+
+	priv->pspi_dev_num = (enum pspi_dev)plat->dev_num;
+	priv->pspi_regs = (struct npcm750_pspi_regs *)plat->regs;
+
+	gpio_request_by_name_nodev(offset_to_ofnode(node), "cs-gpios", 0,
+				&plat->cs_gpio, GPIOD_IS_OUT);
+
+	return 0;
+}
+
+
+static const struct dm_spi_ops npcm750_pspi_ops = {
+	.claim_bus      = npcm750_pspi_claim_bus,
+	.release_bus    = npcm750_pspi_release_bus,
+	.xfer           = npcm750_pspi_xfer,
+	.set_speed      = npcm750_pspi_set_speed,
+	.set_mode       = npcm750_pspi_set_mode,
+	/*
+	 * cs_info is not needed, since we require all chip selects to be
+	 * in the device tree explicitly
+	 */
+};
+
+static const struct udevice_id npcm750_pspi_ids[] = {
+	{ .compatible = "nuvoton,npcm750-pspi"},
+	{ }
+};
+
+U_BOOT_DRIVER(npcm750_pspi) = {
+	.name   = "npcm750_pspi",
+	.id     = UCLASS_SPI,
+	.of_match = npcm750_pspi_ids,
+	.ops    = &npcm750_pspi_ops,
+	.ofdata_to_platdata = npcm750_spi_ofdata_to_platdata,
+	.platdata_auto_alloc_size = sizeof(struct npcm750_pspi_platdata),
+	.priv_auto_alloc_size = sizeof(struct npcm750_pspi_priv),
+	.probe  = npcm750_pspi_probe,
+};
diff -Naur a/drivers/spi/spi-mem.c b/drivers/spi/spi-mem.c
--- a/drivers/spi/spi-mem.c	2019-07-22 22:57:53.000000000 -0400
+++ b/drivers/spi/spi-mem.c	2020-06-04 10:31:09.726216862 -0400
@@ -330,6 +330,15 @@
 		return -EIO;
 #else
 
+	/* U-Boot does not support parallel SPI data lanes */
+	if ((op->cmd.buswidth != 1) ||
+	    (op->addr.nbytes && op->addr.buswidth != 1) ||
+	    (op->dummy.nbytes && op->dummy.buswidth != 1) ||
+	    (op->data.nbytes && op->data.buswidth != 1)) {
+		printf("Dual/Quad raw SPI transfers not supported\n");
+		return -ENOTSUPP;
+	}
+
 	if (op->data.nbytes) {
 		if (op->data.dir == SPI_MEM_DATA_IN)
 			rx_buf = op->data.buf.in;
